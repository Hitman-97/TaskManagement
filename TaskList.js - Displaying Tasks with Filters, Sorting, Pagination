import React, { useState, useMemo, useCallback, useEffect } from 'react';
import useTaskStore from './TaskStore';
import Task from './Task';
import TaskModal from './TaskModal';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';

const TaskList = () => {
  const { tasks, filters, sort, currentPage, tasksPerPage, setSort, setPage, setFilters } = useTaskStore();
  
  const [modalOpen, setModalOpen] = useState(false);
  const [editTask, setEditTask] = useState(null);

  // Filtering tasks
  const filteredTasks = useMemo(() => {
    let filtered = [...tasks.values()];
    if (filters.search) {
      filtered = filtered.filter(task =>
        task.title.toLowerCase().includes(filters.search.toLowerCase())
      );
    }
    if (filters.status !== 'all') {
      filtered = filtered.filter(task => task.status === filters.status);
    }
    return filtered;
  }, [tasks, filters]);

  // Sorting tasks
  const sortedTasks = useMemo(() => {
    return filteredTasks.sort((a, b) => {
      if (sort === 'asc') {
        return a.title.localeCompare(b.title);
      } else {
        return b.title.localeCompare(a.title);
      }
    });
  }, [filteredTasks, sort]);

  // Pagination logic
  const paginatedTasks = useMemo(() => {
    const startIndex = (currentPage - 1) * tasksPerPage;
    const endIndex = startIndex + tasksPerPage;
    return sortedTasks.slice(startIndex, endIndex);
  }, [sortedTasks, currentPage, tasksPerPage]);

  // Handling page change
  const handlePageChange = (page) => {
    setPage(page);
  };

  const handleSort = useCallback(() => {
    setSort(sort === 'asc' ? 'desc' : 'asc');
  }, [sort, setSort]);

  const handleFilterChange = (e) => {
    setFilters({ ...filters, search: e.target.value });
  };

  const handleStatusFilterChange = (e) => {
    setFilters({ ...filters, status: e.target.value });
  };

  const openModal = (task) => {
    setEditTask(task);
    setModalOpen(true);
  };

  const closeModal = () => {
    setModalOpen(false);
    setEditTask(null);
  };

  return (
    <div>
      <input 
        type="text" 
        value={filters.search} 
        onChange={handleFilterChange} 
        placeholder="Search tasks..." 
      />
      <select onChange={handleStatusFilterChange} value={filters.status}>
        <option value="all">All</option>
        <option value="completed">Completed</option>
        <option value="pending">Pending</option>
      </select>
      <button onClick={handleSort}>Sort {sort === 'asc' ? 'Asc' : 'Desc'}</button>
      
      <DragDropContext onDragEnd={() => { /* Handle drag and drop */ }}>
        <Droppable droppableId="tasks">
          {(provided) => (
            <div ref={provided.innerRef} {...provided.droppableProps}>
              {paginatedTasks.map((task, index) => (
                <Draggable key={task.email} draggableId={task.email} index={index}>
                  {(provided) => (
                    <div
                      ref={provided.innerRef}
                      {...provided.draggableProps}
                      {...provided.dragHandleProps}
                    >
                      <Task task={task} openModal={openModal} />
                    </div>
                  )}
                </Draggable>
              ))}
              {provided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>

      <div>
        {Array.from({ length: Math.ceil(sortedTasks.length / tasksPerPage) }, (_, i) => (
          <button key={i} onClick={() => handlePageChange(i + 1)}>
            {i + 1}
          </button>
        ))}
      </div>

      {modalOpen && <TaskModal task={editTask} closeModal={closeModal} />}
    </div>
  );
};

export default TaskList;
